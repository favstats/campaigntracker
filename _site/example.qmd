---
title: ""
format:
  html:
    theme: lumen
    page-layout: full
    self-contained: true
    code-fold: true
    code-overflow: wrap
    html-math-method: mathjax
    includes:
      in-header: |
        <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
---

```{r setup, include=FALSE}
# dir()
# here::i_am("ep2024.Rproj")

library(tidyverse)
library(htmltools)
htmltools::tags$script(src = "https://cdn.jsdelivr.net/npm/apexcharts")
knitr::opts_chunk$set(echo = F, message = F, warning = F)

# sets <- jsonlite::fromJSON(here::here("settings.json"))




library(glue)
# write_csv(aidat, file = "../data/aidat.csv")

```


> Willkommen beim **CampAIgn Tracker**, Ihrer **go-to Plattform** zur Überwachung des Einsatzes von **KI-generierten Inhalten** in politischen Kampagnen. *Derzeit* konzentriert sich unsere Analyse auf *bezahlte Werbung auf Meta-Plattformen* von offiziellen Parteiaccounts in Deutschland und bietet Einblicke in **Targeting-Strategien**, **Ausgabemuster** und **die Verbreitung von KI-generierten Bildern und Botschaften**.

```{r}
# cleaned_content <- readRDS("../data/cleaned_content.rds")
labeled <- readRDS("../data/labeled.rds")

ai_dat <- readRDS("../data/ai_dat.rds")



workwith <- labeled %>% 
  # count(ki_bild_video) %>% 
  mutate(ai = ifelse(str_detect(ki_bild_video, "Ja", negate = T) | is.na(ki_bild_video), 0, 1)) %>%
  mutate(ai = sample(c(0, 1,1,0,0), nrow(labeled), replace = T)) %>% 
  bind_rows(
    ai_dat %>% mutate(ai = ifelse(ai_generated >= 0.5, 1, 0))
  ) %>% 
  mutate(party = case_when(
    party == "AFD" ~ "AfD",
    party == "BüSo – Bürgerrechtsbewegung Solidarität" ~ "BüSo",
    party %in% c("CDU", "CSU") ~ "CDU/CSU",
    party %in% c("MLPD – Marxistisch-Leninistische Partei Deutschlands") ~ "MLPD",
    party %in% c("Piratenpartei Deutschland", "Piratenpartei") ~ "Piratenpartei",
    party %in% c("SSW - Südschleswiger Wählerverband") ~ "SSW",
    party %in% c("V-Partei³ - Partei für Veränderung, Vegetarier und Veganer") ~ "V-Partei³",
    str_detect(party, "ÖDP") ~ "ÖDP",
    str_detect(party, "PdF") ~ "PdF",
    T ~party
  ))


 # write_csv(workwith, "workwith.csv")
```



```{r}
# workwith %>% count(party)

# profile_handle
# Example: Print the first 10 values
# head(binary_numbers, 10)
party_data <- workwith %>%
  count(ai, party) %>%
  group_by(party) %>%
  mutate(total = sum(n)) %>%
  ungroup() %>%
  mutate(proportion = n / total * 100)

library(highcharter)


# Render both charts
# overall_chart
# Sort parties by the proportion of AI = 1 (descending)
sorted_party_data <- party_data %>%
  group_by(party) %>%
  summarize(ai_1_proportion = proportion[ai == 1]) %>%
  arrange(desc(ai_1_proportion)) %>%
  left_join(party_data, by = "party")

# Get the sorted party names
sorted_parties <- unique(sorted_party_data$party)

library(highcharter)
library(htmltools)
```



## AI Content by Party

```{r, results='asis'}
create_political_treemap <- function(
  data,
  title = "AI Content Distribution by Political Party",
  height = 400
) {
  # Official German party color mapping
  party_colors <- c(
    "CDU/CSU" = "#000000",       # Black
    "SPD" = "#E3000F",           # Red
    "AfD" = "#009EE0",           # Light Blue
    "FDP" = "#FFED00",           # Yellow
    "B90/GRÜNE" = "#46962B",     # Green
    "LINKE" = "#BE3075",         # Magenta
    "BSW" = "#782151",           # Dark Blue
    "Freie Wähler" = "#f6a800",  # Orange
    "DieBasis" = "#7F7F7F",      # Gray
    "Piratenpartei" = "#FF8800", # Orange
    "ÖDP" = "#00AA00",           # Dark Green
    "VOLT" = "#562883",          # Purple
    "NPD/Die Heimat" = "#8B0000",# Dark Red
    "WerteUnion" = "#004B88",     # Blue
    "MLPD" = "#FF0000",           # Bright Red
    "PdF" = "#f5a519",
    "Bayernpartei" = "#97f5fd",
    "V-Partei³" = "#9fbe15",
    "Partei der Humanisten" = "#ff00ff",
    "Die PARTEI" = "#a81e31",
    "DEMOKRATIE IN BEWEGUNG" = "#253c69",
    "NPD /Die Heimat" = "#d59e29"

    #
  )
  
  # Validate data structure
  if (!all(c("x", "y") %in% names(data))) {
    stop("Data must contain 'x' and 'y' columns")
  }
  
  # Match colors to parties
  data_colors <- party_colors[match(data$x, names(party_colors))]
  data_colors[is.na(data_colors)] <- "#CCCCCC"  # Fallback gray
  
  # Convert data to JSON format
  series_data <- jsonlite::toJSON(
    lapply(1:nrow(data), function(i) {
      list(x = data$x[i], y = data$y[i])
    }),
    auto_unbox = TRUE
  )
  
    unique_id <- paste0("chart-", sample(1:10000, 1))  # Generate unique ID

  
  # Create HTML components
  htmltools::tagList(
    htmltools::div(id = "custom-treemap"),  # Changed ID to be unique
    htmltools::tags$script(
      sprintf(
        "
        (function() {
          // Use unique variable names
          var treemapOptions = {
            series: [{ data: %s }],
            legend: { show: false },
            chart: {
              id: 'partyTreemap',
              height: %d,
              type: 'treemap',
              toolbar: { show: false }
            },
            title: {
              text: '%s',
              align: 'center',
              style: { fontSize: '16px' }
            },
            colors: %s,
            plotOptions: {
              treemap: {
                distributed: true,
                enableShades: false,
                dataLabels: {
                  style: { fontSize: '12px' }
                }
              }
            },
            tooltip: {
              style: { fontSize: '14px', color: '#000000' },
              marker: { show: true, size: 20 }
            }
          };
          
          // Wait for DOM readiness
          document.addEventListener('DOMContentLoaded', function() {
            var treemapChart = new ApexCharts(
              document.querySelector('#custom-treemap'),
              treemapOptions
            );
            treemapChart.render();
          });
        })();
        ",
        series_data,
        height,
        title,
        jsonlite::toJSON(as.character(data_colors))
      )
    )
  )
}


# Create sample data
cities_data <- data.frame(
  x = sorted_party_data %>% arrange(desc(n)) %>% 
  filter(ai == 1) %>% pull(party),
  y = sorted_party_data %>% arrange(desc(n)) %>% 
  filter(ai == 1) %>% pull(n)
)

# Generate the treemap
tm <- create_political_treemap(
  data = cities_data,
  title = "Usage of AI by Party",
  height = 400
)

# Display in RStudio Viewer or browser
htmltools::browsable(tm)
# htmltools::html_print(tm)
# htmltools::HTML(as.character(tm))

# htmltools::save_html(as.character(tm), file = "t.html")
```


## AI Proportion by Party

```{r}
library(apexcharter)
library(dplyr)

# Assuming sorted_party_data and sorted_parties are already defined

# Prepare data for Apexcharter
# Sorting by AI proportion
sorted_data <- sorted_party_data %>%
  group_by(party) %>%
  summarise(ai_proportion = sum(proportion[ai == 1]), .groups = 'drop') %>%
  arrange(desc(ai_proportion)) %>%
  left_join(sorted_party_data, by = "party") %>%
  mutate(ai_label = ifelse(ai == 1, "AI = 1", "AI = 0"))

# Reshape data for Apexcharter
data_for_apex <- sorted_data %>%
  pivot_wider(names_from = ai_label, values_from = proportion, values_fill = 0)

# Create the bar chart with tight spacing
apex_chart <- apexchart() %>%
  ax_chart(type = "bar", stacked = TRUE, height = "5000px") %>%  # Ensure stacking is enabled
  ax_plotOptions(
    bar = list(
      horizontal = TRUE,       # Horizontal bars
      barHeight = "70%",      # Adjust bar height to reduce space
      columnWidth = "85%"      # Adjust column width for spacing control
    )
  ) %>%
  ax_xaxis(categories = unique(data_for_apex$party)) %>%
  ax_series(
      list(
      name = "AI = 0",
      data = data_for_apex %>% filter(ai == 0) %>% pull(`AI = 0`)
    ),
    list(
      name = "AI = 1",
      data = data_for_apex %>% filter(ai == 1) %>% pull(ai_proportion)
    )

  ) %>%
  ax_colors(c("#6c757d", "#17a2b8")) %>%
  ax_dataLabels(enabled = TRUE, formatter = JS("function(val) { return val + '%'; }")) %>%
  ax_legend(position = "top") %>%
  ax_title(text = "AI Proportion by Party (Sorted)") %>%
  ax_dataLabels(enabled = TRUE, formatter = JS("function(val) { return Math.round(val) + '%'; }"))

# Custom CSS for Responsive Container
custom_css <- tags$style(HTML("
  .apex-legends {
    max-width: 100%;
    height: auto;
    overflow-x: auto;    /* Horizontal scroll if needed */
    overflow-y: auto;    /* Vertical scroll if needed */
    padding: 20px;
    background-color: #f8f9fa; /* Light background */
    border: 1px solid #ccc;    /* Subtle border */
    border-radius: 10px;       /* Rounded corners */
  }
"))



# Embedding Chart into Responsive Container
# htmltools::tagList(
#   custom_css,
#   tags$div(
#     class = "apex-legends",
    apex_chart
#   )
# )
```

